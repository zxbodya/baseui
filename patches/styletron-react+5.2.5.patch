diff --git a/node_modules/styletron-react/src/__tests__/tests.browser.js b/node_modules/styletron-react/src/__tests__/tests.browser.js
new file mode 100644
index 0000000..62aaa35
--- /dev/null
+++ b/node_modules/styletron-react/src/__tests__/tests.browser.js
@@ -0,0 +1,758 @@
+// @flow
+
+import test from "tape";
+import Enzyme from "enzyme";
+import Adapter from "enzyme-adapter-react-16";
+import * as React from "react";
+
+import {
+  styled,
+  createStyled,
+  withWrapper,
+  withStyle,
+  withTransform,
+  Provider,
+  useStyletron,
+} from "../index.js";
+
+import {getInitialStyle, driver} from "styletron-standard";
+
+Enzyme.configure({adapter: new Adapter()});
+
+test("styled (static)", t => {
+  t.plan(3);
+  const style = {color: "red"};
+  const Widget = styled("div", style);
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, style);
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget />
+    </Provider>,
+  );
+  const wrapper = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "bar",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget className="foo" />
+    </Provider>,
+  );
+  const divs = wrapper.find("div");
+  t.equal(divs.length, 1, "single div rendered");
+  t.ok(divs.hasClass("foo bar"), "explicit and generated class names merged");
+  t.end();
+});
+
+test("styled (dynamic)", t => {
+  t.plan(1);
+  const Widget = styled("div", (props: {$foo: boolean}) => ({
+    color: props.$foo ? "red" : "blue",
+  }));
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {color: "red"});
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget $foo={true} />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("withStyle (static)", t => {
+  t.plan(1);
+  const Widget = styled("div", {
+    borderWidth: 0,
+    color: "red",
+    ":hover": {fontSize: "12px"},
+  });
+  const SuperWidget = withStyle(Widget, {
+    color: "blue",
+    ":hover": {borderWidth: "10px"},
+  });
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            borderWidth: 0,
+            color: "blue",
+            ":hover": {fontSize: "12px", borderWidth: "10px"},
+          });
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <SuperWidget />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("withStyle (dynamic)", t => {
+  t.plan(1);
+  const Widget = styled("div", {
+    lineHeight: 1,
+    color: "red",
+    ":hover": {fontSize: "12px"},
+  });
+  const SuperWidget = withStyle(Widget, props => ({
+    background: props.$round ? "yellow" : "green",
+    ":hover": {borderWidth: 0},
+  }));
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            color: "red",
+            background: "yellow",
+            lineHeight: 1,
+            ":hover": {borderWidth: 0, fontSize: "12px"},
+          });
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <SuperWidget $round={true} />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("$style prop (static)", t => {
+  t.plan(1);
+  const Widget = styled("div", {
+    lineHeight: 1,
+    color: "red",
+    ":hover": {fontSize: "12px"},
+  });
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            color: "blue",
+            lineHeight: 1,
+            ":hover": {fontSize: "12px"},
+          });
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget $style={{color: "blue"}} />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("$style prop (dynamic)", t => {
+  t.plan(1);
+  const Widget = styled("div", {
+    lineHeight: 1,
+    color: "red",
+    ":hover": {fontSize: "12px"},
+  });
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            color: "blue",
+            background: "yellow",
+            lineHeight: 1,
+            ":hover": {fontSize: "12px", borderWidth: 0},
+          });
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget
+        $style={props => ({
+          color: "blue",
+          background: props.$round ? "yellow" : "green",
+          ":hover": {borderWidth: 0},
+        })}
+        $round={true}
+      />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("$style overrides nested withStyle", t => {
+  t.plan(1);
+  const Widget = styled("div", {
+    color: "red",
+    fontSize: "12px",
+  });
+
+  const WidgetColor = withStyle(Widget, {color: "blue"});
+  const WidgetFontSize = withStyle(WidgetColor, {fontSize: "14px"});
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            color: "yellow",
+            fontSize: "14px",
+            padding: "10px",
+          });
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <WidgetFontSize
+        $style={{
+          color: "yellow",
+          padding: "10px",
+        }}
+      />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("withTransform", t => {
+  t.plan(1);
+  const Widget = styled("div", {color: "red", background: "green"});
+  const SuperWidget = withTransform(Widget, (style, props) => ({
+    ...style,
+    background: props.$round ? "yellow" : "green",
+  }));
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {color: "red", background: "yellow"});
+          return "";
+        },
+        renderFontFace: () => {
+          return "";
+        },
+        renderKeyframes: () => {
+          return "";
+        },
+      }}
+    >
+      <SuperWidget $round={true} />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("$as works", t => {
+  t.plan(2);
+  const Widget = styled("div", {});
+  const MockComponent = props => {
+    t.equal(props.className, "foo", "styled class is passed");
+    return <div />;
+  };
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "foo",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget $as={MockComponent} />
+    </Provider>,
+  );
+  const wrapper = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget $as="span" />
+    </Provider>,
+  );
+  t.equal(wrapper.find("span").length, 1, "span rendered");
+  t.end();
+});
+
+test("$-prefixed props not passed", t => {
+  t.plan(1);
+
+  class InnerComponent extends React.Component<{className: string}> {
+    render() {
+      t.deepEqual(
+        this.props,
+        {
+          className: "styleclass",
+          "data-bar": "bar",
+        },
+        "props match expected",
+      );
+      return <button>InnerComponent</button>;
+    }
+  }
+
+  const Widget = styled(InnerComponent, {color: "red"});
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "styleclass",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget $foo="foo" $baz="baz" data-bar="bar" />
+    </Provider>,
+  );
+});
+
+test("callback ref forwarding", t => {
+  t.plan(1);
+
+  const Widget = styled("button", {color: "red"});
+  class TestComponent extends React.Component<{}> {
+    widgetInner: ?HTMLButtonElement;
+    componentDidMount() {
+      t.ok(this.widgetInner instanceof HTMLButtonElement, "is button");
+    }
+
+    render() {
+      return (
+        <Provider
+          value={{
+            renderStyle: () => "",
+            renderKeyframes: () => "",
+            renderFontFace: () => "",
+          }}
+        >
+          <Widget
+            ref={c => {
+              this.widgetInner = c;
+            }}
+          />
+        </Provider>
+      );
+    }
+  }
+  Enzyme.mount(<TestComponent />);
+});
+
+test("React.createRef() ref forwarding", t => {
+  t.plan(1);
+
+  const Widget = styled("button", {color: "red"});
+  class TestComponent extends React.Component<{}> {
+    widgetInner: {
+      current: React.ElementRef<any> | null,
+    } = React.createRef();
+
+    componentDidMount() {
+      t.ok(this.widgetInner.current instanceof HTMLButtonElement, "is button");
+    }
+
+    render() {
+      return (
+        <Provider
+          value={{
+            renderStyle: () => "",
+            renderKeyframes: () => "",
+            renderFontFace: () => "",
+          }}
+        >
+          <Widget ref={this.widgetInner} />
+        </Provider>
+      );
+    }
+  }
+  Enzyme.mount(<TestComponent />);
+});
+
+test("React.useRef() ref forwarding", t => {
+  t.plan(1);
+  const Widget = styled("button", {color: "red"});
+  const TestComponent = () => {
+    const widgetInner = React.useRef(null);
+    React.useEffect(() => {
+      t.ok(widgetInner.current instanceof HTMLButtonElement, "is button");
+    }, []);
+    return (
+      <Provider
+        value={{
+          renderStyle: () => "",
+          renderKeyframes: () => "",
+          renderFontFace: () => "",
+        }}
+      >
+        <Widget ref={widgetInner} />
+      </Provider>
+    );
+  };
+
+  Enzyme.mount(<TestComponent />);
+});
+
+test("legacy string ref forwarding", t => {
+  t.plan(1);
+
+  const Widget = styled("button", {color: "red"});
+  class TestComponent extends React.Component<{}> {
+    componentDidMount() {
+      t.ok(this.refs.myButton instanceof HTMLButtonElement, "is button");
+    }
+    render() {
+      return (
+        <Provider
+          value={{
+            renderStyle: () => "",
+            renderKeyframes: () => "",
+            renderFontFace: () => "",
+          }}
+        >
+          <Widget ref="myButton" />
+        </Provider>
+      );
+    }
+  }
+  Enzyme.mount(<TestComponent />);
+});
+
+test("withWrapper", t => {
+  t.plan(6);
+  const Widget = styled("button", {color: "red"});
+  const WrappedWidget = withWrapper(Widget, StyledElement => props => {
+    t.deepEqual(props, {foo: "bar"}, "props passed");
+    return (
+      <section>
+        <StyledElement {...props} />
+      </section>
+    );
+  });
+  const wrapper1 = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: style => {
+          t.deepEqual(style, {color: "red"});
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <WrappedWidget foo="bar" />
+    </Provider>,
+  );
+  t.equal(wrapper1.find("section").length, 1, "wrapper rendered");
+
+  const DeluxeWrappedWidget = withStyle(WrappedWidget, {color: "blue"});
+  const wrapper2 = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: style => {
+          t.deepEqual(
+            style,
+            {color: "blue"},
+            "style composition works after wrapping",
+          );
+          return "";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <DeluxeWrappedWidget foo="bar" />
+    </Provider>,
+  );
+  t.equal(
+    wrapper2.find("section").length,
+    1,
+    "wrapper rendered after composition",
+  );
+
+  t.end();
+});
+
+test("styled debug mode (client only)", t => {
+  t.plan(7);
+
+  let debugCallCount = 0;
+
+  const style = {color: "red"};
+  const Widget = styled("div", style);
+
+  const wrapper = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "bar",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+      debug={{
+        debug: ({stackIndex, stackInfo}) => {
+          debugCallCount++;
+          t.equal(stackIndex, 2, "stackIndex matches expected");
+          t.equal(typeof stackInfo, "object", "stackInfo is an object");
+          t.equal(
+            typeof stackInfo.stack,
+            "string",
+            "stackInfo.stack is a string (chrome)",
+          );
+          t.equal(
+            typeof stackInfo.message,
+            "string",
+            "stackInfo.message is a string (chrome)",
+          );
+          return "__arbitrary_debug_class__";
+        },
+      }}
+    >
+      <Widget className="foo" />
+    </Provider>,
+  );
+
+  const divs = wrapper.find("div");
+  t.equal(divs.length, 1, "single div rendered");
+  t.ok(divs.hasClass("__arbitrary_debug_class__ foo bar"), "adds debug class");
+  wrapper.unmount();
+  wrapper.mount();
+  wrapper.unmount();
+  t.equal(debugCallCount, 1, "debug only called on initial render");
+});
+
+test("styled debug mode (ssr)", t => {
+  t.plan(3);
+  const style = {color: "red"};
+  let count = 0;
+  const Widget = styled("div", style);
+  const wrapper = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => {
+          count++;
+          return "foo";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+      debug={{
+        debug: () => {
+          t.equal(count, 2, "debug class fetched during second render");
+          return "__some_debug_class";
+        },
+      }}
+      debugAfterHydration
+    >
+      <Widget />
+    </Provider>,
+  );
+  const divs = wrapper.find("div");
+  t.equal(count, 2, "renders twice");
+  t.ok(
+    divs.hasClass("__some_debug_class foo"),
+    "explicit and generated class names merged",
+  );
+  t.end();
+});
+
+test("font-face injection", t => {
+  t.plan(2);
+  const fontFace = {
+    src: "foo",
+  };
+  const style = {fontFamily: fontFace};
+  const Widget = styled("div", style);
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            fontFamily: "foo",
+          });
+          return "";
+        },
+        renderFontFace: x => {
+          t.deepEqual(x, fontFace);
+          return "foo";
+        },
+        renderKeyframes: () => "",
+      }}
+    >
+      <Widget />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("keyframes injection", t => {
+  t.plan(2);
+  const keyframes = {
+    from: {color: "red"},
+    to: {color: "green"},
+  };
+  const style = {animationName: keyframes};
+  const Widget = styled("div", style);
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            animationName: "foo",
+          });
+          return "";
+        },
+        renderKeyframes: x => {
+          t.deepEqual(x, keyframes);
+          return "foo";
+        },
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("createStyled wrapper", t => {
+  t.plan(1);
+
+  const customStyled = createStyled({
+    driver,
+    getInitialStyle,
+    wrapper: _Component => props => {
+      t.equal(props.foo, "foo");
+      return <div>hello world</div>;
+    },
+  });
+  const Widget = customStyled("div", {color: "red"});
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Widget foo="foo" />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("useStyletron css", t => {
+  t.plan(2);
+
+  function Link() {
+    const [css] = useStyletron();
+    const className = css({color: "blue"});
+    t.equal(className, ".abc");
+    return <a className={className}>Foo</a>;
+  }
+
+  Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: x => {
+          t.deepEqual(x, {
+            color: "blue",
+          });
+          return ".abc";
+        },
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+    >
+      <Link />
+    </Provider>,
+  );
+  t.end();
+});
+
+test("useStyletron debug mode", t => {
+  t.plan(3);
+
+  function Widget() {
+    const [css] = useStyletron();
+    const [on, setOn] = React.useState(false);
+    const className = css({color: "red"});
+    return (
+      <button onClick={() => setOn(!on)} className={className}>
+        test
+      </button>
+    );
+  }
+
+  let debugCallCount = 0;
+  const wrapper = Enzyme.mount(
+    <Provider
+      value={{
+        renderStyle: () => "bar",
+        renderKeyframes: () => "",
+        renderFontFace: () => "",
+      }}
+      debug={{
+        debug: () => {
+          debugCallCount++;
+          return `__debug-${debugCallCount}`;
+        },
+      }}
+    >
+      <Widget />
+    </Provider>,
+  );
+
+  const button = wrapper.find("button");
+  t.ok(button.hasClass("__debug-1 bar"), "adds debug class");
+  button.simulate("click");
+  t.ok(button.hasClass("__debug-1 bar"), "adds debug class");
+  t.equal(debugCallCount, 1, "debug only called on initial render");
+});
+
+test("no-op engine", t => {
+  t.plan(1);
+  const consoleWarn = console.warn; // eslint-disable-line
+
+  (console: any).warn = message => {
+    t.equal(
+      message.split("\n")[1],
+      "Styletron has been switched to a no-op (test) mode.",
+    );
+  };
+  const Widget = styled("div", {
+    color: "red",
+  });
+  Enzyme.mount(<Widget />);
+
+  (console: any).warn = consoleWarn;
+  t.end();
+});
diff --git a/node_modules/styletron-react/src/dev-tool.d.ts b/node_modules/styletron-react/src/dev-tool.d.ts
new file mode 100644
index 0000000..ab52923
--- /dev/null
+++ b/node_modules/styletron-react/src/dev-tool.d.ts
@@ -0,0 +1,19 @@
+export declare function addDebugMetadata(instance: any, stackIndex: any): void;
+export declare const setupDevtoolsExtension: () => void;
+declare class BrowserDebugEngine {
+    private worker;
+    private counter;
+    constructor(worker: any);
+    debug({ stackIndex, stackInfo }: {
+        stackIndex: any;
+        stackInfo: any;
+    }): string;
+}
+declare class NoopDebugEngine {
+    debug(): void;
+}
+declare global {
+    var __BROWSER__: boolean;
+}
+export declare const DebugEngine: typeof BrowserDebugEngine | typeof NoopDebugEngine;
+export {};
diff --git a/node_modules/styletron-react/src/index.d.ts b/node_modules/styletron-react/src/index.d.ts
new file mode 100644
index 0000000..16d2380
--- /dev/null
+++ b/node_modules/styletron-react/src/index.d.ts
@@ -0,0 +1,53 @@
+declare global {
+    interface Window {
+        __STYLETRON_DEVTOOLS__: any;
+    }
+}
+import * as React from "react";
+import { driver, StandardEngine, StyleObject } from "styletron-standard";
+import { Styletron, ReducerContainer, AssignmentCommutativeReducerContainer, StyledFn, WithStyleFn, WithTransformFn, WithWrapperFn, StyletronProps } from "./types";
+import { DebugEngine } from "./dev-tool";
+export { DebugEngine };
+export { StyleObject };
+export { StyletronProps };
+declare type DevProviderProps = {
+    children: React.ReactNode;
+    value: StandardEngine;
+    debugAfterHydration?: boolean;
+    debug?: any;
+};
+declare class DevProvider extends React.Component<DevProviderProps, {
+    hydrating: boolean;
+}> {
+    constructor(props: DevProviderProps);
+    componentDidMount(): void;
+    render(): JSX.Element;
+}
+export declare const Provider: typeof DevProvider | React.ProviderExoticComponent<React.ProviderProps<StandardEngine>>;
+export declare function DevConsumer(props: {
+    children: (c: any, b: any, a: any) => React.ReactNode;
+}): JSX.Element;
+declare type createStyledOpts = {
+    getInitialStyle: () => StyleObject;
+    driver: typeof driver;
+    wrapper: (a: React.FC<any>) => React.ComponentType<any>;
+};
+export declare function useStyletron(): ((style: StyleObject) => string)[];
+export declare function createStyled({ getInitialStyle, driver, wrapper, }: createStyledOpts): StyledFn;
+export declare const styled: StyledFn;
+export declare const withTransform: WithTransformFn;
+export declare const withStyleDeep: WithStyleFn;
+export declare const withStyle: WithStyleFn;
+export declare const withWrapper: WithWrapperFn;
+export declare function autoComposeShallow<Props>(styletron: Styletron, styleArg: StyleObject | ((a: Props) => StyleObject)): Styletron;
+export declare function autoComposeDeep<Props>(styletron: Styletron, styleArg: StyleObject | ((a: Props) => StyleObject)): Styletron;
+export declare function staticComposeShallow(styletron: Styletron, style: StyleObject): Styletron;
+export declare function staticComposeDeep(styletron: Styletron, style: StyleObject): Styletron;
+export declare function dynamicComposeShallow<Props>(styletron: Styletron, styleFn: (a: Props) => StyleObject): Styletron;
+export declare function dynamicComposeDeep<Props>(styletron: Styletron, styleFn: (a: Props) => StyleObject): Styletron;
+export declare function createShallowMergeReducer(style: StyleObject): AssignmentCommutativeReducerContainer;
+export declare function createDeepMergeReducer(style: StyleObject): AssignmentCommutativeReducerContainer;
+export declare function composeStatic(styletron: Styletron, reducerContainer: AssignmentCommutativeReducerContainer): Styletron;
+export declare function composeDynamic<Props>(styletron: Styletron, reducer: (b: StyleObject, a: Props) => StyleObject): Styletron;
+export declare function createStyledElementComponent(styletron: Styletron): any;
+export declare function resolveStyle(getInitialStyle: (a: void) => StyleObject, reducers: Array<ReducerContainer>, props: any): StyleObject;
diff --git a/node_modules/styletron-react/src/index.js b/node_modules/styletron-react/src/index.js
index 337e3f4..1b6ed17 100644
--- a/node_modules/styletron-react/src/index.js
+++ b/node_modules/styletron-react/src/index.js
@@ -32,6 +32,7 @@ import {
 } from "./dev-tool.js";
 
 export {DebugEngine};
+export type {StyleObject};
 
 const noopEngine = {
   renderStyle: () => "",
@@ -166,8 +167,8 @@ export function useStyletron() {
 
       const nextDeps = [debugEngine, hydrating];
       if (
-        prevDebugClassNameDeps[0] !== nextDeps[0] ||
-        prevDebugClassNameDeps[1] !== nextDeps[1]
+        prevDebugClassNameDeps.current[0] !== nextDeps[0] ||
+        prevDebugClassNameDeps.current[1] !== nextDeps[1]
       ) {
         if (debugEngine && !hydrating) {
           debugClassName.current = debugEngine.debug({
diff --git a/node_modules/styletron-react/src/types.d.ts b/node_modules/styletron-react/src/types.d.ts
new file mode 100644
index 0000000..be8f4f9
--- /dev/null
+++ b/node_modules/styletron-react/src/types.d.ts
@@ -0,0 +1,59 @@
+import * as React from "react";
+import { ComponentType } from "react";
+import { StyleObject } from "styletron-standard";
+export declare type AssignmentCommutativeReducerContainer = {
+    assignmentCommutative: true;
+    reducer: (a: StyleObject) => StyleObject;
+    style: StyleObject;
+    factory: (a: StyleObject) => AssignmentCommutativeReducerContainer;
+};
+export declare type NonAssignmentCommutativeReducerContainer = {
+    assignmentCommutative: false;
+    reducer: (b: StyleObject, a: any) => StyleObject;
+};
+export declare type ReducerContainer = AssignmentCommutativeReducerContainer | NonAssignmentCommutativeReducerContainer;
+export declare type Styletron = {
+    reducers: Array<ReducerContainer>;
+    base: any;
+    driver: any;
+    name?: string;
+    wrapper: any;
+    getInitialStyle: any;
+    ext?: {
+        name?: string;
+        base: any;
+        getInitialStyle: any;
+        with: any;
+    };
+    debug?: {
+        stackIndex: number;
+        stackInfo: {
+            stack: any;
+            stacktrace: any;
+            message: any;
+        };
+    };
+};
+export declare type StyletronProps<Props = {}> = Partial<{
+    $style: StyleObject | ((props: Props) => StyleObject);
+    $as: ComponentType<any> | keyof JSX.IntrinsicElements;
+    className: string;
+    /** @deprecated */
+    $ref: Props extends {
+        ref?: infer T;
+    } ? T : React.Ref<any>;
+    ref: Props extends {
+        ref?: infer T;
+    } ? T : React.Ref<any>;
+}>;
+export declare type StyletronComponent<Props> = React.FC<Props & StyletronProps<Props>> & {
+    __STYLETRON__: any;
+};
+export declare type StyledFn = {
+    <T extends keyof JSX.IntrinsicElements | ComponentType<any>, Props>(component: T, style: StyleObject | ((a: Props) => StyleObject)): StyletronComponent<(T extends ComponentType<infer BaseProps> ? BaseProps : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : {}) & Props>;
+};
+export declare type WithStyleFn = {
+    <Base extends StyletronComponent<any>, Props = {}>(comnponent: Base, a: StyleObject | ((a: Props) => StyleObject)): StyletronComponent<(Base extends StyletronComponent<infer BaseProps> ? BaseProps : never) & Props>;
+};
+export declare type WithTransformFn = <Base extends StyletronComponent<any>, Props>(b: Base, a: (b: StyleObject, a: Props) => StyleObject) => StyletronComponent<(Base extends StyletronComponent<infer BaseProps> ? BaseProps : never) & Props>;
+export declare type WithWrapperFn = <Base extends StyletronComponent<any>, Props>(component: Base, wrapper: (a: Base) => ComponentType<Props>) => StyletronComponent<(Base extends StyletronComponent<infer BaseProps> ? BaseProps : never) & Props>;
